; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 2
; RUN: opt < %s -mtriple=amdgcn -passes=gvn -S | FileCheck %s

define void @no_replace_uniform_with_non0(ptr %buf) {
; CHECK-LABEL: define void @no_replace_uniform_with_non0
; CHECK-SAME: (ptr [[BUF:%.*]]) {
; CHECK-NEXT:    [[V1:%.*]] = load i32, ptr [[BUF]], align 4
; CHECK-NEXT:    [[V2:%.*]] = call i32 @llvm.amdgcn.readfirstlane(i32 [[V1]])
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[V1]], [[V2]]
; CHECK-NEXT:    br i1 [[COND]], label [[MATCHES:%.*]], label [[END:%.*]]
; CHECK:       matches:
; CHECK-NEXT:    call void @opaque(i32 [[V2]])
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    call void @opaque(i32 [[V1]])
; CHECK-NEXT:    ret void
;
  %v1 = load i32, ptr %buf
  %v2 = call i32 @llvm.amdgcn.readfirstlane(i32 %v1)
  %cond = icmp eq i32 %v1, %v2
  br i1 %cond, label %matches, label %end

; Make sure we don't replace %v2 with %v1 when %v2 is known to be uniform
matches:
  call void @opaque(i32 %v2)
  br label %end

end:
  call void @opaque(i32 %v1)
  ret void
}

define void @no_replace_uniform_with_non0_swapped(ptr %buf) {
; CHECK-LABEL: define void @no_replace_uniform_with_non0_swapped
; CHECK-SAME: (ptr [[BUF:%.*]]) {
; CHECK-NEXT:    [[V1:%.*]] = load i32, ptr [[BUF]], align 4
; CHECK-NEXT:    [[V2:%.*]] = call i32 @llvm.amdgcn.readfirstlane(i32 [[V1]])
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[V2]], [[V1]]
; CHECK-NEXT:    br i1 [[COND]], label [[MATCHES:%.*]], label [[END:%.*]]
; CHECK:       matches:
; CHECK-NEXT:    call void @opaque(i32 [[V2]])
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    call void @opaque(i32 [[V1]])
; CHECK-NEXT:    ret void
;
  %v1 = load i32, ptr %buf
  %v2 = call i32 @llvm.amdgcn.readfirstlane(i32 %v1)
  %cond = icmp eq i32 %v2, %v1
  br i1 %cond, label %matches, label %end

; Make sure we don't replace %v2 with %v1 when %v2 is known to be uniform
matches:
  call void @opaque(i32 %v2)
  br label %end

end:
  call void @opaque(i32 %v1)
  ret void
}

define void @replace_non_uniform_with_uniform0(ptr %buf) {
; CHECK-LABEL: define void @replace_non_uniform_with_uniform0
; CHECK-SAME: (ptr [[BUF:%.*]]) {
; CHECK-NEXT:    [[V1:%.*]] = load i32, ptr [[BUF]], align 4
; CHECK-NEXT:    [[V2:%.*]] = call i32 @llvm.amdgcn.readfirstlane(i32 [[V1]])
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[V1]], [[V2]]
; CHECK-NEXT:    br i1 [[COND]], label [[MATCHES:%.*]], label [[END:%.*]]
; CHECK:       matches:
; CHECK-NEXT:    call void @opaque(i32 [[V1]])
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    call void @opaque(i32 [[V1]])
; CHECK-NEXT:    ret void
;
  %v1 = load i32, ptr %buf
  %v2 = call i32 @llvm.amdgcn.readfirstlane(i32 %v1)
  %cond = icmp eq i32 %v1, %v2
  br i1 %cond, label %matches, label %end

matches:
  call void @opaque(i32 %v1)
  br label %end

end:
  call void @opaque(i32 %v1)
  ret void
}

define void @replace_non_uniform_with_uniform0_swapped(ptr %buf) {
; CHECK-LABEL: define void @replace_non_uniform_with_uniform0_swapped
; CHECK-SAME: (ptr [[BUF:%.*]]) {
; CHECK-NEXT:    [[V1:%.*]] = load i32, ptr [[BUF]], align 4
; CHECK-NEXT:    [[V2:%.*]] = call i32 @llvm.amdgcn.readfirstlane(i32 [[V1]])
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[V2]], [[V1]]
; CHECK-NEXT:    br i1 [[COND]], label [[MATCHES:%.*]], label [[END:%.*]]
; CHECK:       matches:
; CHECK-NEXT:    call void @opaque(i32 [[V1]])
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    call void @opaque(i32 [[V1]])
; CHECK-NEXT:    ret void
;
  %v1 = load i32, ptr %buf
  %v2 = call i32 @llvm.amdgcn.readfirstlane(i32 %v1)
  %cond = icmp eq i32 %v2, %v1
  br i1 %cond, label %matches, label %end

matches:
  call void @opaque(i32 %v1)
  br label %end

end:
  call void @opaque(i32 %v1)
  ret void
}

define void @no_replace_uniform_with_non1(ptr %buf) {
; CHECK-LABEL: define void @no_replace_uniform_with_non1
; CHECK-SAME: (ptr [[BUF:%.*]]) {
; CHECK-NEXT:    [[V1:%.*]] = load i32, ptr [[BUF]], align 4
; CHECK-NEXT:    [[V2:%.*]] = call i32 @llvm.amdgcn.readfirstlane(i32 [[V1]])
; CHECK-NEXT:    [[V3:%.*]] = add i32 [[V2]], 1
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[V1]], [[V3]]
; CHECK-NEXT:    br i1 [[COND]], label [[MATCHES:%.*]], label [[END:%.*]]
; CHECK:       matches:
; CHECK-NEXT:    call void @opaque(i32 [[V3]])
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    call void @opaque(i32 [[V1]])
; CHECK-NEXT:    ret void
;
  %v1 = load i32, ptr %buf
  %v2 = call i32 @llvm.amdgcn.readfirstlane(i32 %v1)
  %v3 = add i32 %v2, 1
  %cond = icmp eq i32 %v1, %v3
  br i1 %cond, label %matches, label %end

matches:
  call void @opaque(i32 %v3)
  br label %end

end:
  call void @opaque(i32 %v1)
  ret void
}

define void @replace_non_uniform_with_uniform1(ptr %buf, ptr %buf2) {
; CHECK-LABEL: define void @replace_non_uniform_with_uniform1
; CHECK-SAME: (ptr [[BUF:%.*]], ptr [[BUF2:%.*]]) {
; CHECK-NEXT:    [[V1:%.*]] = load i32, ptr [[BUF]], align 4
; CHECK-NEXT:    [[V2:%.*]] = call i32 @llvm.amdgcn.readfirstlane(i32 [[V1]])
; CHECK-NEXT:    [[V3:%.*]] = load i32, ptr [[BUF2]], align 4
; CHECK-NEXT:    [[COND:%.*]] = icmp eq i32 [[V2]], [[V3]]
; CHECK-NEXT:    br i1 [[COND]], label [[MATCHES:%.*]], label [[END:%.*]]
; CHECK:       matches:
; CHECK-NEXT:    call void @opaque(i32 [[V3]])
; CHECK-NEXT:    br label [[END]]
; CHECK:       end:
; CHECK-NEXT:    call void @opaque(i32 [[V3]])
; CHECK-NEXT:    ret void
;
  %v1 = load i32, ptr %buf
  %v2 = call i32 @llvm.amdgcn.readfirstlane(i32 %v1)
  %v3 = load i32, ptr %buf2
  %cond = icmp eq i32 %v2, %v3
  br i1 %cond, label %matches, label %end

matches:
  call void @opaque(i32 %v3)
  br label %end

end:
  call void @opaque(i32 %v3)
  ret void
}

define void @no_hoist_across_loops(ptr %buf, ptr %buf2) {
; CHECK-LABEL: define void @no_hoist_across_loops
; CHECK-SAME: (ptr [[BUF:%.*]], ptr [[BUF2:%.*]]) {
; CHECK-NEXT:    [[V1:%.*]] = load i32, ptr [[BUF]], align 4
; CHECK-NEXT:    br label [[LOOP1:%.*]]
; CHECK:       loop1:
; CHECK-NEXT:    [[S1:%.*]] = call i32 @llvm.amdgcn.readfirstlane(i32 [[V1]])
; CHECK-NEXT:    [[COND1:%.*]] = icmp eq i32 [[S1]], [[V1]]
; CHECK-NEXT:    br i1 [[COND1]], label [[MATCH1:%.*]], label [[LOOP1]]
; CHECK:       match1:
; CHECK-NEXT:    call void @opaque(i32 0)
; CHECK-NEXT:    br label [[LOOP2:%.*]]
; CHECK:       loop2:
; CHECK-NEXT:    [[S2:%.*]] = call i32 @llvm.amdgcn.readfirstlane(i32 [[V1]])
; CHECK-NEXT:    [[COND2:%.*]] = icmp eq i32 [[S2]], [[V1]]
; CHECK-NEXT:    br i1 [[COND2]], label [[MATCH2:%.*]], label [[LOOP2]]
; CHECK:       match2:
; CHECK-NEXT:    call void @opaque(i32 1)
; CHECK-NEXT:    ret void
;
  %v1 = load i32, ptr %buf
  br label %loop1

loop1:
  %s1 = call i32 @llvm.amdgcn.readfirstlane(i32 %v1)
  %cond1 = icmp eq i32 %s1, %v1
  br i1 %cond1, label %match1, label %loop1

match1:
  call void @opaque(i32 0)
  br label %loop2

loop2:
  %s2 = call i32 @llvm.amdgcn.readfirstlane(i32 %v1)
  %cond2 = icmp eq i32 %s2, %v1
  br i1 %cond2, label %match2, label %loop2

match2:
  call void @opaque(i32 1)
  br label %end

end:
  ret void
}

declare i32 @llvm.amdgcn.readfirstlane(i32) nounwind readnone
declare void @opaque(i32)
